# 周报23-12-3（魏春锡）

## 日期范围：2023-11-28——2023-12-3

## 遇到的问题

### 程序计数器（概念）

是计算机体系结构中的一个寄存器，通常用于存储正在执行的指令的地址或下一条指令的地址。在单处理系统中，程序计数器是一种非常重要的寄存器，它指示了CPU正在执行的指令的位置。

作用：指令地址存储、顺序执行、分支和跳转、异常处理、上下问切换、程序的开始和结束

#### 进程与线程

##### 定义

**进程**：进程是一个程序运行中单独开辟空间运行的一个程序。每一个进程都有自己的空间。

**线程**：线程是进程之中执行的一个控制单元或者说是一个任务，一个进程之中的多个线程共享资源（堆和字符串常量池），但每一个线程都有自己的程序计数器、虚拟机栈、本地方法栈。

进程和线程的比较：

- **独立性：**
  - 进程是独立的执行单位，一个进程的崩溃通常不会影响其他进程。
  - 线程是进程的执行单元，同一进程中的所有线程共享相同的内存空间和资源。
- **通信：**
  - 进程之间的通信相对复杂，需要使用 IPC 机制。
  - 线程之间的通信相对简单，可以直接读写共享数据。
- **资源开销：**
  - 进程的创建和销毁比较慢，占用较多系统资源。
  - 线程的创建和销毁相对快，占用较少系统资源。
- **切换开销：**
  - 进程切换开销较大，因为需要切换独立的内存空间和系统资源。
  - 线程切换开销较小，因为线程共享相同的内存空间和资源。

##### IPC

> IPC（Inter-Process Communication）是一种用于在不同进程之间传递数据和信息的机制。由于进程拥有独立的内存空间，为了使它们能够相互通信和协作，需要使用特定的机制来实现数据传递。以下是一些常见的 IPC 机制：
>
> 1. **管道（Pipes）：**
>    - 管道是一种单向通信机制，可以在两个相关的进程之间传递数据。有两种类型的管道：匿名管道（只能在相关进程之间使用）和命名管道（允许无关的进程之间通信）。
> 2. **消息队列（Message Queues）：**
>    - 消息队列是一个在两个无关进程之间传递数据的通信机制。发送方将消息放入队列，接收方从队列中取出消息。消息队列可以实现异步通信。
> 3. **共享内存（Shared Memory）：**
>    - 共享内存允许多个进程访问相同的内存区域，因此可以直接共享数据。这是一种高效的通信机制，但需要注意同步问题，以防止数据竞争。
> 4. **信号量（Semaphores）：**
>    - 信号量是一种用于进程同步的 IPC 机制。它可以用于控制对共享资源的访问，防止多个进程同时访问。
> 5. **套接字（Sockets）：**
>    - 套接字是一种网络编程中常用的 IPC 机制，允许不同计算机上的进程进行通信。套接字可以用于实现进程之间的通信，即使它们运行在同一台计算机上。
> 6. **信号（Signals）：**
>    - 信号是一种异步通信机制，用于通知进程发生了某个事件。例如，进程可以通过发送信号给另一个进程来通知它终止。
> 7. **文件锁（File Locking）：**
>    - 文件锁可以用于协调多个进程对文件的访问。通过在文件上设置锁，可以防止多个进程同时对文件进行写操作。
> 8. **消息传递（Message Passing）：**
>    - 消息传递是一种直接通过消息进行通信的机制，允许一个进程向另一个进程发送消息。这可以通过操作系统提供的消息传递机制或编程语言提供的消息传递库来实现。

##### 线程的生命周期

分为线程创建、线程就绪、线程运行、线程等待、线程堵塞、线程销毁。

##### 线程创建的5种方法

https://zhuanlan.zhihu.com/p/643667712#:~:text=%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BA%94%E7%A7%8D%E6%96%B9%E5%BC%8F%201%20%E7%BB%A7%E6%89%BFThread%E7%B1%BB%202%20%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3,3%20%E4%BD%BF%E7%94%A8Callable%E5%92%8CFuture%204%20%E4%BD%BF%E7%94%A8Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%205%20%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0

##### 并发与并行的区别

- **并发**：两个及两个以上的作业在同一 **时间段** 内执行。
- **并行**：两个及两个以上的作业在同一 **时刻** 执行。

最关键的点是：是否是 **同时** 执行。

##### 同步和异步的区别

- **同步**：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。
- **异步**：调用在发出之后，不用等待返回结果，该调用直接返回。

##### 如何理解线程安全和不安全？

线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。

- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

##### 什么是线程上下文切换?

线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。

- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
- 被终止或结束运行

这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 **上下文切换**

##### sleep() 方法和 wait() 方法对比

**共同点**：两者都可以暂停线程的执行。

**区别**：

- **`sleep()` 方法没有释放锁，而 `wait()` 方法释放了锁** 。
- `wait()` 通常被用于线程间交互/通信，`sleep()`通常被用于暂停执行。
- `wait()` 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 `notify()`或者 `notifyAll()` 方法。`sleep()`方法执行完成后，线程会自动苏醒，或者也可以使用 `wait(long timeout)` 超时后线程会自动苏醒。
- `sleep()` 是 `Thread` 类的静态本地方法，`wait()` 则是 `Object` 类的本地方法
## 学习心得

学习不能间断。

## 感受

好的机遇需要遇到，而不是梦到。但遇到需要有能力拿住。
