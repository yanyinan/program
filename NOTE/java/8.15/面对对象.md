# 面向对象

## 抽象数据类型

### 面向对象的基本概念

#### 面向对象

面向对象程序设计（`OOP`）是一种基于对象概念的软件开发方法。

#### 面向对象三大特性：

封装、继承、多态

#### 对象

在面向对象的世界中认为万事万物皆为对象。

> 对象的简单理解就是真实存在的具体的个体。

#### 类

类是具有相同的状态和相同行为的一组对象的集合

> 类的简单理解就是代表多个的统称，而不是具体个体。

#### 类和对象的关系

类和对象的关系就如同模具和利用这个模具制作出来的物品之间的关系。一个类给出它的全部对象的一个统一的定义，而它的每个对象则是符合这个定义的一个实体（也称作实例），因此类和对象的关系就是抽象和具体的关系。类是多个对象进行综合抽象的结果，是实体对象的概念模型，而一个对象就是一个类的实例。

### 定义类

类是由字段和方法构成的。

![img](https://s2.loli.net/2023/08/16/mzT4ADWQl1prPw9.png)

#### 定义

语法：

```java
public class ClassName {
    // 成员变量
    private dataType variableName;

    // 构造方法
    public ClassName() {
        // 初始化操作
    }

    // 成员方法
    public void methodName(dataType parameter) {
        // 方法体
    }
}

```

#### 类的字段

类的内部包含字段和方法、对象所拥有的特征在类中表示时称为类的字段，字段使用变量表示。

定义语法：

```java
[访问修饰符] 数据类型 字段名;
```

#### 类的方法

对象执行操作的行为称为类的方法。

### 创建和使用对象

#### 创建对象

类是一类事物的集合和抽象，代表着这类事物共有的字段和行为。一个对象称为类的一个实例。

类的对象可以调用类中的成员。

创建对象的语法：

```java
类名 对象名 = new 类名();
```

#### 使用对象

在`java`中，要引用对象的字段和方法，需要使用成员运算符`.`

使用语法：

```java
对象名.属性//引用对象的字段
对象名.方法名()//引用对象的方法
```

> 对象的指针分配在栈中，对象的实例分配在堆中

## 对象的构造和初始化

调用构造方法时，步骤如下

1. 分配新对象的空间，并进行默认的初始化。
2. 执行显式的成员初始化。
3. 执行构造方法。

### 成员变量

#### 成员变量的作用域

类中低端是直接定义在类的内部、方法的外部的变量。称为成员变量。

成员变量的作用域是整个类。

#### 显式成员初始化

如果在成员说明中鞋油简单的复制表达式，就可以在构造对象时进行显示的成员初始化。

演示：

```java
public class CarTest{
	public static void main(String[] args){
		Car c1 = new Car();//创建对象并将地址赋给变量c1
		c1.run();//对象的引用c1调用函数run();
		Car c2 = new Car();//创建对象并将地址赋给变量c2
		c2.run();//对象的引用c2调用函数run();
		Car c3 = new Car();//创建对象并将地址赋给变量c3
		c3.brand="BYD";//将"BYD"赋给成员变量brand
		c3.run();//c3再次调用run()
	}
}
class Car{
	String brand="BMW";//成员变量 品牌=BMW
	char color='b';//成员变量 颜色=b
	public void run(){
		System.out.println("品牌:"+brand+" 颜色:"+color);
	}
}

```

#### 局部变量的作用域

局部变量就是定义在方法内部的变量。

局部方法只能在方法内部使用。

#### 成员变量、局部变量的区别

1. **作用域不同。**局部变量的作用域仅限定于定义它的方法，在该方法外无法被访问。成员变量的作用域是在整个类中，所有的成员方法都可以使用它。。如果访问权限允许，还有可以在类外部使用成员变量。
2. **初始值不同。**对于成员变量，如果在类定义中没有给它赋予初始值，`java`会给它赋予默认值。但不贵给局部变量赋予，因此局部变量在使用前必须初始化。
3. 在同一个方法中不允许有同名的局部变量，在不同的方法中可以有同名的局部变量。
4. 局部变量可以和成员变量名相同，并且在使用时局部变量有更高的优先级。

#### 按值传递

参数是在方法定义中声明的变量，用于接收传递给方法的值，而实参则是在方法调用时传递给方法的具体值。

### 构造方法

在Java中，**当创建一个类的对象时，会自动调用该类的构造方法**。构造方法分为**默认构造方法**和**自定义构造方法**。构造方法是一种特殊的实例方法，具有特殊的功能。它的名称与类名相同，**没有返回值**，并且在使用n**ew关键字创建对象实例时会自动被调用**。

#### 构造方法的定义

构造方法的作用是为成员变量的初始化。

定义构造方法的语法格式：

```java
[访问修饰符] 方法名([参数列表]){
	//省略方法体的代码
}
```

在缺少自定义构造方法的情况下，`Java`会**自动添加**一个默认构造方法。<u>该默认方法不带任何参数</u>。

**默认构造方法的参数列表及方法体均为空，所生成的对象的属性值也为零或空**

#### 方法的重载

##### 定义

方法重载是指在一个类中定义多个同名的方法，但要求每个方法具有不同的参数类型或参数个数或参数顺序。

##### 特点

- 在同一个类中
- 参数的个数或者类型或者顺序不同
- 方法的返回值不能作为方法是否构成重载的依据

##### 调用

在调用时，根据实参与形参在类型、个数、顺序一一匹配的规则调用。

##### 优点

是对原有方法的一种升级，可以根据参数的不同，采用不同的实现方法，而且不需要编写多个名称，简化了调用方法的代码。

#### 构造方法的重载

构造方法也可以同普通方法一样进行重载。

## 内存管理

#### 垃圾回收



#### 内存分配



#### 内存管理技术



## 包的使用

### 概述

包是类的容器，利用包来划分名字空间， 用于分割类名空间，以避免类名冲突。

包主要有以下3个方面的作用：

1. 存放类：包中能够存放类，易于找到和使用相应的类文件。
2. 防止命名冲突：`Java`中只有在不同的包中的类才能重名。
3. 包允许在更广的范围内保护类、数据和方法。

### 定义

语法

```
package 包名;
```

> 一个唯一的包名前缀通常是全部小写的`ASCLL`字母。
>
> 不能以`JAVA`或`Javax`开头

### tips

1. 声明包的含义是声明当前类所在的包。
2. 导入包的含义是声明当前类要使用到其他类所在的包。
3. 使用非同包下的类需要显导报或者使用全限定类名
4. 同包下或子包下的类不需要导包
5. `java.lang `包下的类不需要导包

## 访问修饰符

### 类和类成员的访问控制

访问修饰符有3个（4种）。`public`、`protected`、`package-access(包访问修饰符)`、`private`

> public访问修饰符

被该修饰符修饰的成员变量和成员方法可以在所有类中访问。

> protected访问修饰符

被该修饰符修饰的成员变量和成员方法可以在声明它的类中访问，在该类的子类中访问，也可以在与该类位于同一个包中的类访问，但不能再位于其他包的非子类中访问。

> package-access(包访问修饰符)

缺省指不使用权限修饰符。不使用权限修饰符修饰的成员变量和成员方法可以在声明它的类中访问，也可以在该类位于同一个包中的类访问，但不能位于其他包的类（包括子类）中访问。

>private访问修饰符

被该修饰符修饰的成员变量和成员方法只能在声明他们的类中访问，而不能再其它类（包括子类）中访问。

#### 1、类的访问修饰符

|                                | 同一包中 |  不同包中  |
| :----------------------------: | :------: | :--------: |
|            `public`            | 可以使用 |  可以使用  |
| `package-access(包访问修饰符)` | 可以使用 | 不可以使用 |

#### 2、类成员的访问修饰符

|       位置       | public | protected | 包访问修饰符 | private |
| :--------------: | :----: | :-------: | :----------: | :-----: |
|     同类访问     |  true  |   true    |     true     |  true   |
|  同包其他类访问  |  true  |   true    |     true     |  false  |
|   同包子类访问   |  true  |   true    |     true     |  false  |
|  不同包子类访问  |  true  |   true    |    false     |  false  |
| 不同包非子类访问 |  true  |   false   |    false     |  false  |

### static关键字

#### static修饰属性

使用static修饰的属性称为静态属性或类变量，没有使用static修饰的属性称为实例变量。使用static修饰的属性属于类，不属于具体的某个对象。类属性在类的首次加载时初始化。

#### static修饰方法

类方法不依赖与任何对象，用类名直接加“`.`”调用，对象名也可以调用。使用static修饰的方法属于类，不属于具体的某个对象。

>1、静态方法不能直接访问实例变量和实例方法。
>
>2、在实例方法中够可以直接调用类中定义的静态变量和静态方法。

#### 静态初始化

Java中的静态初始化是一种在类被加载时执行的初始化方式，用于初始化类的静态变量和执行一些静态代码块。

语法：

```java
static{
    //静态初始化代码块
}
```

> 静态初始化代码块在类被加载时**只执行一次**，且只能访问类的静态变量和方法。
>
> 静态初始化的执行顺序是按照代码块在类中出现的顺序依次执行的。
>
> 静态初始化可以用来完成一些静态资源的初始化。
>
> 也可以用来执行一些需要再类加载时执行的操作。

### 静态成员与实例成员的区别

1. 静态成员是类的成员，实例成员是对象的成员。静态成员是在类加载时初始化，只有一个副本，可以被类的所有成员共享；实例成员是在对象创建时初始化，每个对象都有自己的一份。
2. 静态成员可以直接通过类名访问，不需要创建对象；实例成员需要通过对象来访问。
3. 静态成员不能直接访问实例成员，但实例成员可以访问静态成员和实例成员。这是因为在实例化对象之前， 静态成员已经被初始化，而实例成员需要通过对象来访问。
4. 静态成员可以在静态初始化中初始化，实例成员需要在构造函数或实例初始化中初始化。建泰成员适合存储类级别的信息；实例成员适合存在对象级别的信息。

## 封装

### 实质：

Java中的封装的实质就是将类的状态信息（成员变量）、方法等隐藏在类的内部，不允许外补程序直接访问，而是通过该类提供的方法来实现对隐藏信息（成员变量）的操作和访问。在Java中，可以使用访问修饰符来控制类中的数据和方法的访问级别，从而实现封装。

### 优点

封装反映了事物相对的独立性，有效避免了外部错误对此对象的影响。

1. 防止外部直接访问类的内部数据，可以保护数据的安全性。
2. 通过限制外部访问，可以更好地控制数据的正确性和完整性。
3. 可以隐藏类的实现细节，使得类的永远忽不需要了解类的内部实现细节，只需要知道如何使用类提供的接口。

### 步骤

1. 修改字段的可见性

   > 将访问修饰符修改为private，其他类就无法访问。

2. 设置`getter/setter`方法

   - 常见的`getter/setter`方法规则如下

     1. Getter方法

        >命名规则：使用属性名前加上"get"作为方法前缀，属性名的首字母通常大写
        >
        >返回类型：通常与属性的类型相同
        >
        >方法体：直接返回属性的值

     2. Setter方法

        >命名规则：使用属性名前加上"set"作为方法前缀，属性名的首字母通常大写
        >
        >参数：通常只有一参数，参数类型与属性的类型相同
        >
        >方法体：将传入的参数值赋给属性

     3. 布尔类型属性的Getter方法

        >命名规则：使用属性名前加上"is"作为方法前缀，属性名的首字母通常大写
        >
        >返回类型：通常是布尔类型
        >
        >方法体：返回属性的值

3. 设置字段的存储限制

   > 可以再setter方法中利用条件判断语句进行赋值限制

### 意义

封装的主要目的是隐藏类的内部实现细节，防止外部直接访问类的内部数据和方法，从而保证类的安全性和稳定性。优点如下：

1. 隐藏类的内部细节，使得类的用户只需要知道如何使用类的接口，而不需要关心类的具体实现细节。这样可以更好地降低类的使用难度，提高代码的可维护性和可读性。
2. 通过限制外部访问，可以更好地控制数据的正确性和完整性。通过封装，可以确保类的数据只能被有限的访问者访问和修改，从而避免了意外的数据损坏和数据安全问题。
3. 可以更加灵活地修改类的内部实现，而不会影响到类的用户。
4. 封装可以提高代码的重用性，通过封装可以将类的内部实现独立出来，形成单独的模块，是得这些模块可以再不同的应用程序中重复使用。

### 遮蔽

#### 概念

遮蔽指的是在一个作用域中使用了一个和外层作用域相同的变量名，导致内部变量遮蔽了外部变量，即无法直接访问外部变量。

#### 使用

局部变量遮蔽成员变量：当一个方法中的参数或者局部变量和成员变量同名时，方法内部就无法直接访问该数组变量，此时需要使用关键字this来应用当前对象的成员变量。

#### 例如

```java
public class Test {
    private int value = 10;

    void method(int value) {
        // this.value = 20; // 错误，因为value已经被局部变量遮蔽了
        this.value += 10; // 正确，可以通过this.value来访问成员变量
    }
}
```

### this

1. 引用当前对象的成员变量

2. 调用当前对象的成员方法

3. 调用当前对象的构造方法

   > 只能在有效语句的第一行

## 继承

### 一些基本概念

1. **子类可以继承父类的非私有属性和方法**。子类可以使用父类的属性和方法，无需重写编写相同的代码。
2. **子类可以添加自己的属性和方法**。子类可以增加父类中没有的属性和方法，从而增加代码的灵活性和可拓展性。
3. **子类的构造方法可以调用父类的构造方法**。在子类的构造方法中使用super关键字可以调用父类的构造方法，从而初始化父类的属性。**但不能继承构造方法**。
4. **Object类是所有类的根类**。
5. Java中的类只支持单一继承，每个类只能有一个父类（直接父类）。**单继承特性**
6. **子类可以成为其他类的父类，从而建立多级继承关系**。

tips：

继承提供了一种有效的方式类重用代码和组织类层次结构。但是，过度使用会导致复杂的代码结构和性能问题。

### 示例

```java
// 父类：动物
class Animal {
    String name;

    public void eat() {
        System.out.println("动物吃东西");
    }

    public void sleep() {
        System.out.println("动物睡觉");
    }
}

// 子类：狗
class Dog extends Animal {
    public void bark() {
        System.out.println("狗叫");
    }
}

// 测试类
public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        dog.name = "旺财";
        dog.eat(); // 调用父类的方法
        dog.sleep(); // 调用父类的方法
        dog.bark(); // 子类自己的方法
    }
}

```

#### 使用继承实现子类以及super关键字调用

1. 使用继承定义部门类及子类

2. 使用**super**关键字调用父类成员

   super的目的是访问直接父类中被隐藏的内容，进一步提高代码的重用性和灵活性。

   > 其可以访问父类的构造方法，还可以访问父类的成员，包括父类的字段、普通方法等。
   >
   > 语法规则：
   >
   > 调用父类构造方法：**super([实参列表]);**
   >
   > 调用父类属性和方法：**super.<父类字段名/方法名>**

### this和super的区别

| 区别         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| 调用方法     | this访问本类中的方法，包括从父类继承的方法；super访问父类的方法。 |
| 调用构造方法 | this([参数列表])表示调用本类的构造方法，必须放在构造方法的首行；super.([参数列表])表示调用父类构造，必须放在子类构造方法的首行。如果表示用父类的无参构造，即super()可省略。 |
| 调用字段     | this. 字段：调用的时当前对象的字段，包括从父类继承的字段；super.字段：调用父类中的字段。 |
| 使用         | this在实例方法中可以使用，在static方法中不能使用，每个类都有this；super在实例方法中可以使用，在static方法中不能使用，只能出现在子类。 |
| 其他区别     | this表示当前对象，super不能表示当前对象。                    |

### 重写

在子类中可以以根据需求对从父类继承的方法进行重新编写，这称为方法的重写或方法的覆盖。

方法重写需满足以下要求：

1. 在继承关系中。
2. 重写方法与被重写方法必须有相同的方法名称。
3. 重写方法与被重写方法必须有相同的参数列表。
4. 重写方法的返回值类型必须和被重写方法的返回值类型相同或是其子类。
5. 重写方法缩小被重写方法的访问权限。
6. 不能用子类的非静态犯法重写（覆盖）父类的静态方法，否则编译错误。
7. 不能重写父类中的最终方法。
8. 不能用子类的静态方法重写父类的实例方法。

### 重载和方法重写的区别

方法重载指的是在同一个类中，定义了多个方法，它们的方法名相同但参数列表不同（参数类型、个数和顺序）。编译器会根据不同参数列表自动匹配调用对应的方法。方法重载的目的是为了提高代码的复用性和可读性。

方法重写指的是子类重写了父类的方法，方法名和参数列表都相同。重写方法必须与父类方法的返回类型、异常抛出等相同或兼容。当我们调用一个对象的被重写的方法时，实际上会调用子类中的方法，而不是父类中的方法。重写方法的目的是为了改变方法的实现方式，使得子类可以根据自己的特殊需求来实现父类的方法。

**总的来说，方法重载是在一个类中定义多个同名但参数不同的方法，而方法重写是在子类中重写父类的方法，方法名和参数都相同。方法重载是编译时对台，方法重写是运行时多态。**

### final关键字

在Java中，final是一个关键字，用于修饰变量、方法和类，表示他们是不可改变的或不可继承的。

1. **final修饰变量：final修饰的变量称为常量，一旦被初始化，就无法再次被修改。**
2. **final修饰方法：final修饰的方法称为不可覆盖方法，子类无法重写该方法。**
3. **final修饰类：final修饰的类称为不可继承类，表示该类不能被其他类继承。**

### 方法隐藏

父类和子类拥有相同名字的属性或者方法（方法隐藏只有一种形式，就是父类和子类存在签名相同的静态方法）时，父类的同名属性或者方法形式上不见了，实际还是存在。

#### 示例

```java
class Parent {
    public void method() {
        System.out.println("Parent method");
    }
}

class Child extends Parent {
    // 隐藏父类的 method() 方法
    public void method() {
        System.out.println("Child method");
    }

    public static void main(String[] args) {
        Child child = new Child();
        child.method(); // 输出 "Child method"
    }
}

```

### Object类

Object类是Java语言中类层次结构的根类，也就是说任何一个类都是该类的直接或者间接子类。如果定义一个Java类时没有使用extends关键字声明其父类，则其父类为`java.lang.Object`类。Object类定义了“对象”的基本行为，被子类继承并实现  。

Java Object 类可以解决参数的统一问题，也就是说使用 Object类可以接收所有的数据类型。在Java中，只有Object不存在继承关系，所有类默认情况下都是Object子类。

#### 常用方法

Object类中定义了一些方法，这些方法可以被子类继承和重写。以下是Object类中的一些常用方法：

1. `public String toString()`: 返回对象的字符串表示形式，通常用于调试和日志记录。
2. `public boolean equals(Object obj)`: 比较两个对象是否相等，默认情况下使用引用相等性比较。
3. `public int hashCode()`: 返回对象的哈希码值，用于散列表等数据结构中。
4. `protected void finalize() throws Throwable`: 在对象被垃圾回收器回收之前调用，可以在此方法中释放资源。
5. `public final Class<?> getClass()`: 返回对象的运行时类。
6. `public String getName()`: 返回对象的类名。
7. `public void setName(String name)`: 设置对象的类名。
8. `public Method[] getMethods()`: 返回对象的所有公共方法。
9. `public Object invokeMethod(String name, Object args)`: 调用对象的指定公共方法。
10. `public Object invokeMethod(String name, Object arg1, Object arg2, ...)`: 调用对象的指定公共方法，可变参数。
11. `public Field getField(String name)`: 返回对象的指定公共字段。
12. `public Object getField(String name)`: 返回对象的指定公共字段的值。
13. `public boolean isInstance(Object obj)`: 判断对象是否是该类的实例。
14. `public Class<?> getSuperclass()`: 返回对象的父类。
15. `public boolean isPrimitive()`: 判断对象是否为原始类型。
16. `public void setAccessible(boolean flag)`: 设置对象的可访问标志。

以上是Object类中的一些常用方法，子类可以通过重写这些方法来实现自己的行为。

## 多态

### 基本概念

Java中的多态是指一个引用类型变量可以指向多种实际类型的对象。在Java中，多态的实现主要依赖于继承、接口和方法重写。向上转型（upcasting）和向下转型（downcasting）是多态中的两个重要概念。

### 向上转型（upcasting）：

也称为“子类到父类”的转换或“父类到子类”的转换。当一个子类对象被当作父类对象使用时，就会发生向上转型。向上转型是自动进行的，不需要进行显式转换。例如：

```java
class Animal {
    // ...
}

class Dog extends Animal {
    // ...
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // 向上转型，将Dog对象赋值给Animal类型的变量
    }
}
```

### 向下转型（downcasting）：

也称为“父类到子类”的转换或“子类到父类”的转换。当一个父类对象被当作子类对象使用时，就会发生向下转型。向下转型需要使用强制类型转换符（instanceof），并且可能会抛出ClassCastException异常。例如：

```java
class Animal {
    // ...
}

class Dog extends Animal {
    // ...
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // 向上转型，将Dog对象赋值给Animal类型的变量
        Dog myDog = (Dog) myAnimal; // 向下转型，将Animal类型的变量强制转换为Dog类型
    }
}
```

需要注意的是，在进行向下转型之前，通常需要先使用`instanceof`关键字检查对象是否属于目标子类，以避免ClassCastException异常。例如：

```java
class Animal {
    // ...
}

class Dog extends Animal {
    // ...
}

public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // 向上转型，将Dog对象赋值给Animal类型的变量
        if (myAnimal instanceof Dog) { // 检查myAnimal是否为Dog类型
            Dog myDog = (Dog) myAnimal; // 向下转型，将Animal类型的变量强制转换为Dog类型
        } else {
            System.out.println("myAnimal不是Dog类型");
        }
    }
}
```