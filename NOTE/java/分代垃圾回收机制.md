问题描述
创建对象就会分配内存，不停的创建对象会导致内存溢出0为了防止内存溢出，IVM会对不在使用的对象回收内存问题:
。请说明堆内存中 新生代、老年代、永久代的分代垃圾回收机制

### `JVM`堆

1. **新生代（`Young Generation`）：** 新生代是`JVM`堆内存的一部分，用于存储新创建的对象。`Eden`区和两个`Survivor`区（通常称为`From`和`To`区），也可以说它被进一步划分为三个区域：`Eden`区、`SurvivorFrom`区（通常称为`S0`区）和`SurvivorTo`区（通常称为`S1`区）。新创建的对象首先被分配到`Eden`区，经过一次`Minor GC`（年轻代垃圾回收），仍然存活的对象会被移动到`Survivor`区。在`Survivor`区中，存活对象在多次垃圾回收后可能会晋升到老年代。
2. **老年代（`Old Generation`）：** 老年代用于存储长时间存活的对象和从新生代晋升过来的对象。老年代中的对象会在`Major GC`（老年代垃圾回收）时被清理。
3. **永久代（`Permanent Generation`）：** 永久代在Java 8及以前的版本中用于存储类的元数据、静态变量、常量等。但由于永久代的管理和调优比较复杂，并且容易导致内存泄漏等问题，从Java 8开始，永久代被元空间（`Metaspace`）取代。
4. **元空间（`Metaspace`）：**在旧版本的Java中，类的元数据（比如类的结构、方法等信息）是存储在永久代（Permanent Generation）中的，而这导致了一些内存问题。为了解决这些问题，Java 8引入了元空间的概念，取代了永久代。它用于存储类的元数据信息，如类的结构、方法信息等。它不再位于Java虚拟机的堆内存中，而是位于本地内存中。元空间不受固定内存大小的限制，可以根据应用程序的需要动态地分配和释放内存。

#### 元空间是啥

在`JVM`中，元空间（`Metaspace`）是Java虚拟机中用于存储类元数据的区域，包括类的名称、方法、字段等信息。当加载大量类或者动态生成类时，元空间的内存可能会被耗尽，导致该错误的发生。解决方法包括增加元空间的大小、减少类的加载或者优化代码等  。

#### 清理过程

1.        创建新对象，大多数放在Eden区

2.        `Eden`满了（或达到一定比例），触发`Minor GC`,   把有用的复制到`Survivor1`, 同时清空Eden区。

3.        `Eden`区再次满了，出发`Minor GC`, 把`Eden`和`Survivor1`中有用的，复制到`Survivor2`, 同时清空`Eden`，`Survivor1`。

4.        Eden区第三次满了，出发`Minor GC`, 把`Eden`和`Survivor2`中有用的，复制到`Survivor1`, 同时清空`Eden`，`Survivor2`。

        形成循环，`Survoivor1`和`Survivor`中来回清空、复制，过程中有一个Survivor处于空的状态用于下次复制的。

5.        重复多次（默认15），没有被`Survivor`清理的对象，复制到`Old`（`Tenuerd`）区.

6.        当`Old`达到一定比例，触发`Major GC`，清理老年代。        

7. 当`Old`满了，触发`Full GC`。注意，`Full GC`清理代价大，系统资源消耗高

> 1-5主要使用的复制（Copying）算法