# 抽象类


在Java中，抽象类是一个不能被实例化的类，用于定义一组相关类的通用结构和行为。抽象类可以包含普通方法和抽象方法，而抽象方法只有方法的声明，没有具体实现。子类继承抽象类后，必须实现所有的抽象方法，否则子类也会被定义为抽象类。

## **声明抽象类：

 使用 `abstract` 关键字来声明一个抽象类。抽象类可以包含普通方法（有实际实现）和抽象方法（只有方法签名）。

```java
abstract class<类名>{
    修饰符 数据类型 变量名;
    修饰符 abstract 返回值类型 方法名称(参数列表);
    修饰符 返回值类型 方法名称(参数列表){
        
    }
}
```



## **定义抽象方法：**

 使用 `abstract` 关键字来定义抽象方法。抽象方法没有方法体，只有方法的声明，子类必须提供具体实现。

```java
[访问修饰符] abstract <返回类型><方法名>([参数列表])；
```



## **继承抽象类：**

 子类可以通过使用 `extends` 关键字继承抽象类。如果子类没有实现抽象类中的所有抽象方法，那么子类也必须声明为抽象类。

## **实现抽象方法：**

 在子类中，必须为继承自抽象类的所有抽象方法提供具体的实现。

## 抽象使用小总结

1. `abstract`修饰的抽象方法没有方法体；
2. `private`关键字不能用来修饰抽象方法，否则由于封装导致子类无法重写抽象方法。
3. 抽象类不能直接实例化，但有构造方法。
4. 子类如果不是抽象类，则子类必须重写抽象类中的全部抽象方法。
5. `abstract`修饰符不能和`final`修饰符一起使用。

## 局限性

1. **单继承限制：** Java中，一个类只能继承自一个父类（抽象类或具体类），这就限制了一个子类只能继承一个抽象类。如果某个子类已经继承了一个抽象类，它就不能再继承其他类，这在某些情况下可能会限制类的设计和扩展。
2. **刚性结构：** 一旦一个抽象类的结构（包括方法的签名和属性）确定下来，就很难修改，因为对抽象类的修改可能会影响到所有继承自它的子类。这可能会导致在后续开发阶段需要进行大量的重构工作。
3. **过多的继承层次：** 如果继承层次变得很深，从抽象类到具体子类的多级继承关系可能会变得复杂难以管理。这可能导致代码不易于理解和维护。
4. **灵活性不足：** 抽象类在设计时需要考虑到通用性和结构，可能会导致某些情况下缺乏灵活性。子类必须按照抽象类的框架来实现，这可能会限制特定情况下的定制化需求。
5. **无法与其他类并行使用：** 如果某个类已经继承了一个抽象类，它就不能再继承其他类，这可能会阻碍与其他类的并行使用或集成。

## 抽象类和具体类的比较

1. 抽象类和具体类在定义上的差异：

   > 抽象类是一种不能被实例化的类，它只能被用作其他类的基类。具体类则是可以被示例化的类。

2. 抽象类和具体类在实现上的差异：

   > 抽象类可以包含抽象方法，子类必须实现抽象方法；具体类必须实现它的所有方法，不能有未实现的方法。

3. 抽象类和具体类在使用上的差异：

   > 抽象类通常用于定义一些基础的、通用的行为和属性，而具体类则用于实现具体的业务逻辑和行为。